###########################################################################
#
# File:         SConscript (directory: ./cpp/syck)
# Date:         01-Oct-2008
# Author:       Ken Basye
# Description:  Build and test the syck C library
#
# This file is part of Onyx   http://onyxtools.sourceforge.net
#
# Copyright 2008, 2009 The Johns Hopkins University
#
# Licensed under the Apache License, Version 2.0 (the "License").
# You may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied.  See the License for the specific language governing
# permissions and limitations under the License.
#
###########################################################################

# this controls logging from this troublesome SConscript
debug = False

Import('env')

base_files = [
    'bytecode.c',
    'emitter.c',
    'gram.c',
    'handler.c',
    'implicit.c',
    'node.c',
    'syck.c',
    'syck_st.c',
    'token.c',
    'yaml2byte.c',
    ]

wrapper_files = [
    '_syckmodule.c',
    ]

# XXX We should extract all this platform-dependent stuff to a higher
# level and put what we find out into the environment for SConscripts
# like this one to use and/or we should make a Scons builder for
# shared Python libraries.

import sys
import os
from distutils import sysconfig

# our pre-processor defines
cppdefines = 'DEBUG=1'

# Stuff from distutils used for all platforms
cpppath = [sysconfig.get_python_inc()]
shlibsuffix = sysconfig.get_config_var('SO')

# For each platform we need to fill in these items
shlinkflags = ''
libpath = []
libs = []

if sys.platform == 'darwin':
    # Mac OS X has a clever runtime and doesn't need much to link the shared library
    shlinkflags = env.subst('$LINKFLAGS -bundle -undefined dynamic_lookup')
    libpath = []
    libs = []
else:
    shlinkflags = env.subst('$SHLINKFLAGS')
    (libname, libdir) = sysconfig.get_config_vars('LDLIBRARY', 'LIBDIR')
    libpath = [libdir,]
    if libname.endswith(shlibsuffix):
        libname = libname[:-len(shlibsuffix)]
    libs = [libname]

if debug:
    print 'CPPDEFINES', repr(cppdefines)
    print 'CPPPATH', repr(cpppath)
    print 'SHLIBPREFIX', repr(shlibprefix)
    print 'SHLIBSUFFIX', repr(shlibsuffix)
    print 'SHLINKFLAGS', repr(shlinkflags)
    print 'LIBPATH', repr(libpath)
    print 'LIBS', repr(libs)

# See also code in py/onyx/textdata/yamldata.py that uses the same basename.
syck_shared_base = '_syck'

# Some of the syck code was auto-generated by tools that don't worry about
# warnings, so we suppress them here :-<.
no_warn_env = env.Clone()
no_warn_env.Append(CPPFLAGS = ' -Wno-error')

# Note that we don't define DEBUG=1 for this library, but we do for testing
syck_lib_shared = no_warn_env.SharedLibrary(syck_shared_base, wrapper_files + base_files,
                                         CPPPATH=cpppath,
                                         SHLIBPREFIX='',
                                         SHLIBSUFFIX=shlibsuffix,
                                         SHLINKFLAGS=shlinkflags,
                                         LIBPATH=libpath,
                                         LIBS=libs,
                                         )

if debug: print 'syck_lib_shared', str(syck_lib_shared[0])

# Copy the built shared library to place(s) where a Python that has done 'import
# onyx' will find it.
env.PylibSharedLibrary(syck_shared_base, syck_lib_shared)


# TESTING
syck_lib_static = no_warn_env.StaticLibrary('libsyck.a', base_files,
                                         CPPDEFINES=cppdefines,
                                         CPPPATH=cpppath,
                                         LIBPATH=libpath,
                                         LIBS=libs,
                                         )

cu_test_obj = env.StaticObject('CuTest.o', 'CuTest.c')
    
all_tests = (('test_basic', 'Basic.c'),
             ('test_emit', 'Emit.c'),
             ('test_parse', 'Parse.c'),
             ('test_YTS', 'YTS.c'))


for test_name, test_source in all_tests:
    test = env.Program(test_name, [test_source, cu_test_obj] + syck_lib_static,
                            CPPDEFINES=cppdefines,
                            )

    # run the test to generate a trial log file, then verify this file
    # against the reference; note: use 0 index on SOURCES to ensure we are using
    # just the executable item in test_exe
    test_ref = test_name + '.log-ref'
    log_trial = env.Command(test_name + '.log-trial', test, '${SOURCES[0]} > $TARGET')
    env.Diff(test_name + '.log-diff', [test_ref, log_trial])

